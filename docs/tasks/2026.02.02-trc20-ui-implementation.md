# TRC20 Token UI Implementation Plan

**Date:** 2026-02-02
**Status:** Complete

## Overview

Add TRC20 token functionality to the UI:
1. Add TRC20 tokens (fetch metadata from contract)
2. Display TRC20 token balances
3. Send TRC20 tokens

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/main/kotlin/dev/eastgate/metamaskclone/core/blockchain/BlockchainService.kt` | Add TRC20 methods, update address validation |
| `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/AddTokenDialog.kt` | Support TRON address format, call TRC20 metadata |
| `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/SendTokenDialog.kt` | Enable TRC20 transfers with fee limit field |

---

## Step 1: Add TRC20 Methods to BlockchainService

**File:** `src/main/kotlin/dev/eastgate/metamaskclone/core/blockchain/BlockchainService.kt`

### Add Imports

```kotlin
import org.tron.common.utils.Base58
import java.security.MessageDigest
```

### Add `isValidTronAddress()` with Full Base58Check Validation

Replace the simple format check with full checksum verification:

```kotlin
/**
 * Validate TRON address format with full Base58Check validation.
 * TRON addresses are Base58Check encoded, 34 characters, starting with 'T'.
 */
fun isValidTronAddress(address: String): Boolean {
    // Quick format check
    if (!address.startsWith("T") || address.length != 34) {
        return false
    }

    // Full Base58Check validation with checksum verification
    return try {
        val decoded = Base58.decode(address)
        if (decoded.size < 4) {
            return false
        }

        // Split into address bytes and checksum
        val addressBytes = decoded.copyOfRange(0, decoded.size - 4)
        val checksum = decoded.copyOfRange(decoded.size - 4, decoded.size)

        // Verify checksum = first 4 bytes of SHA256(SHA256(addressBytes))
        val digest = MessageDigest.getInstance("SHA-256")
        val hash1 = digest.digest(addressBytes)
        val hash2 = digest.digest(hash1)
        val expectedChecksum = hash2.copyOfRange(0, 4)

        checksum.contentEquals(expectedChecksum)
    } catch (e: Exception) {
        false
    }
}
```

### Add `getTrc20TokenMetadata()` Method

```kotlin
/**
 * Fetch TRC20 token metadata (symbol, name, decimals) from contract.
 *
 * @param contractAddress The TRC20 contract address (Base58Check format)
 * @param network The TRON network where the token is deployed
 */
suspend fun getTrc20TokenMetadata(
    contractAddress: String,
    network: Network
): TokenMetadataResult =
    withContext(Dispatchers.IO) {
        try {
            if (!isValidTronAddress(contractAddress)) {
                return@withContext TokenMetadataResult.Error("Invalid TRC20 contract address: $contractAddress")
            }

            val client = getTronClient(network)
            val tokenInfo = client.getTrc20TokenInfo(contractAddress)

            TokenMetadataResult.Success(
                symbol = tokenInfo.symbol,
                name = tokenInfo.name,
                decimals = tokenInfo.decimals
            )
        } catch (e: Exception) {
            TokenMetadataResult.Error(e.message ?: "Failed to fetch TRC20 token metadata")
        }
    }
```

### Update `getTokenBalance()` for TRC20 Support

Replace the TRON early-return error with actual TRC20 balance fetching:

```kotlin
suspend fun getTokenBalance(
    contractAddress: String,
    walletAddress: String,
    decimals: Int,
    network: Network
): TokenBalanceResult =
    withContext(Dispatchers.IO) {
        // Handle TRC20 tokens on TRON networks
        if (network.blockchainType == BlockchainType.TRON) {
            return@withContext try {
                if (!isValidTronAddress(contractAddress)) {
                    return@withContext TokenBalanceResult.Error("Invalid TRC20 contract address: $contractAddress")
                }
                if (!isValidTronAddress(walletAddress)) {
                    return@withContext TokenBalanceResult.Error("Invalid wallet address: $walletAddress")
                }

                val client = getTronClient(network)
                val balance = client.getTrc20Balance(walletAddress, contractAddress)

                TokenBalanceResult.Success(
                    balanceRaw = balance.multiply(BigDecimal.TEN.pow(decimals)).toBigInteger(),
                    balanceFormatted = balance.stripTrailingZeros().toPlainString()
                )
            } catch (e: Exception) {
                TokenBalanceResult.Error(e.message ?: "Failed to fetch TRC20 balance")
            }
        }

        // Existing EVM logic below...
    }
```

### Add `sendTrc20Token()` Method

```kotlin
/**
 * Send TRC20 tokens to an address.
 *
 * @param contractAddress The TRC20 contract address
 * @param fromAddress The sender's TRON address
 * @param toAddress The recipient's TRON address
 * @param amount Amount to send in token units (e.g., 10.5 for 10.5 tokens)
 * @param privateKey The sender's private key (hex string)
 * @param network The TRON network to send on
 * @param feeLimit Maximum TRX to burn for energy (in SUN, default: 50 TRX = 50,000,000 SUN)
 */
suspend fun sendTrc20Token(
    contractAddress: String,
    fromAddress: String,
    toAddress: String,
    amount: BigDecimal,
    privateKey: String,
    network: Network,
    feeLimit: Long = 50_000_000L // 50 TRX in SUN
): TokenTransferResult =
    withContext(Dispatchers.IO) {
        try {
            // Validate TRON addresses
            if (!isValidTronAddress(contractAddress)) {
                return@withContext TokenTransferResult.Error("Invalid TRC20 contract address: $contractAddress")
            }
            if (!isValidTronAddress(fromAddress)) {
                return@withContext TokenTransferResult.Error("Invalid from address: $fromAddress")
            }
            if (!isValidTronAddress(toAddress)) {
                return@withContext TokenTransferResult.Error("Invalid to address: $toAddress")
            }

            val client = getTronClient(network)

            // Strip 0x prefix if present
            val cleanPrivateKey = if (privateKey.startsWith("0x")) {
                privateKey.substring(2)
            } else {
                privateKey
            }

            val txId = client.sendTrc20(
                fromAddress = fromAddress,
                toAddress = toAddress,
                contractAddress = contractAddress,
                privateKey = cleanPrivateKey,
                amount = amount,
                feeLimit = feeLimit
            )

            // TRON uses different explorer URL format
            val explorerUrl = network.blockExplorerUrl?.let { "$it/#/transaction/$txId" }

            TokenTransferResult.Success(
                transactionHash = txId,
                explorerUrl = explorerUrl
            )
        } catch (e: Exception) {
            TokenTransferResult.Error(e.message ?: "TRC20 transfer failed")
        }
    }
```

---

## Step 2: Update AddTokenDialog for TRC20 Support

**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/AddTokenDialog.kt`

### Add Import

```kotlin
import dev.eastgate.metamaskclone.models.BlockchainType
```

### Update Tooltip (~line 79)

Show appropriate hint based on network type:

```kotlin
contractAddressField.toolTipText = if (network.blockchainType == BlockchainType.TRON) {
    "TRC20 token contract address (T...)"
} else {
    "Token contract address (0x...)"
}
```

### Modify `fetchTokenMetadata()` (lines 142-183)

Detect TRON network and use appropriate service:

```kotlin
private fun fetchTokenMetadata() {
    val contractAddress = contractAddressField.text.trim()

    // Validate address format
    if (contractAddress.isEmpty()) {
        statusLabel.foreground = JBColor.RED
        statusLabel.text = "Please enter a contract address"
        return
    }

    // Validate based on network type
    if (network.blockchainType == BlockchainType.TRON) {
        if (!blockchainService.isValidTronAddress(contractAddress)) {
            statusLabel.foreground = JBColor.RED
            statusLabel.text = "Invalid TRON address format (must start with T, 34 chars)"
            return
        }
    } else {
        if (!contractAddress.startsWith("0x") || contractAddress.length != 42) {
            statusLabel.foreground = JBColor.RED
            statusLabel.text = "Invalid address format"
            return
        }
    }

    // Start fetching
    fetchButton.isEnabled = false
    statusLabel.foreground = JBColor.GRAY
    statusLabel.text = "Fetching token info..."

    scope.launch {
        val result = if (network.blockchainType == BlockchainType.TRON) {
            blockchainService.getTrc20TokenMetadata(contractAddress, network)
        } else {
            blockchainService.getTokenMetadata(contractAddress, network)
        }

        SwingUtilities.invokeLater {
            when (result) {
                is TokenMetadataResult.Success -> {
                    symbolField.text = result.symbol
                    nameField.text = result.name
                    decimalsField.text = result.decimals.toString()
                    statusLabel.foreground = JBColor(0x4CAF50, 0x81C784)
                    statusLabel.text = "Token info loaded successfully"
                }
                is TokenMetadataResult.Error -> {
                    statusLabel.foreground = JBColor.RED
                    statusLabel.text = "Failed: ${result.message}"
                }
            }
            fetchButton.isEnabled = true
        }
    }
}
```

### Modify `doOKAction()` Validation (lines 185-225)

Support both EVM and TRON address formats:

```kotlin
override fun doOKAction() {
    val contractAddress = contractAddressField.text.trim()
    val symbol = symbolField.text.trim()
    val name = nameField.text.trim()
    val decimalsText = decimalsField.text.trim()

    // Validation
    if (contractAddress.isEmpty()) {
        Messages.showErrorDialog("Please enter a contract address", "Validation Error")
        return
    }

    // Validate based on network type
    if (network.blockchainType == BlockchainType.TRON) {
        if (!blockchainService.isValidTronAddress(contractAddress)) {
            Messages.showErrorDialog(
                "Invalid TRON contract address format. Must be a 34-character address starting with T",
                "Validation Error"
            )
            return
        }
    } else {
        if (!contractAddress.startsWith("0x") || contractAddress.length != 42) {
            Messages.showErrorDialog(
                "Invalid contract address format. Must be a 42-character hex address starting with 0x",
                "Validation Error"
            )
            return
        }
    }

    // Rest of validation unchanged...
}
```

---

## Step 3: Update SendTokenDialog for TRC20 Support

**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/SendTokenDialog.kt`

### Add UI Components

```kotlin
// Fee limit field for TRC20 (only visible for TRON + token transfers)
private val feeLimitField = JBTextField("50")
private lateinit var feeLimitLabel: JLabel
```

### Enable TRC20 Tokens in Selector

Update `setupTokenSelector()` to include tokens for TRON networks:

```kotlin
private fun setupTokenSelector() {
    // Add native token option
    tokenSelector.addItem("${network.symbol} (Native Token)")

    // Add available tokens (ERC20 for EVM, TRC20 for TRON)
    for (t in availableTokens) {
        tokenSelector.addItem("${t.symbol} - ${t.name}")
    }

    // Select the provided token if any
    if (token != null) {
        val index = availableTokens.indexOfFirst { it.id == token.id }
        if (index >= 0) {
            tokenSelector.selectedIndex = index + 1
        }
    }

    // Add listener to update UI when token changes
    tokenSelector.addItemListener { event ->
        if (event.stateChange == java.awt.event.ItemEvent.SELECTED) {
            onTokenSelectionChanged()
        }
    }
}
```

### Add Fee Limit Field to UI

In `createCenterPanel()`, add fee limit field after gas settings (visible only for TRON):

```kotlin
// Fee Limit (TRC20 only)
row++
gbc.gridx = 0
gbc.gridy = row
gbc.gridwidth = 1
gbc.weightx = 0.0
feeLimitLabel = JLabel("Fee Limit (TRX):")
panel.add(feeLimitLabel, gbc)

gbc.gridx = 1
gbc.weightx = 1.0
feeLimitField.toolTipText = "Maximum TRX to burn for energy (default: 50 TRX)"
panel.add(feeLimitField, gbc)

// Initially hide fee limit for native token and EVM networks
feeLimitLabel.isVisible = false
feeLimitField.isVisible = false
```

### Update `onTokenSelectionChanged()`

Show fee limit field when TRC20 token selected:

```kotlin
private fun onTokenSelectionChanged() {
    val isNativeToken = tokenSelector.selectedIndex == 0
    val isTrc20Token = isTronNetwork && !isNativeToken

    // Show/hide fee limit field for TRC20
    feeLimitLabel.isVisible = isTrc20Token
    feeLimitField.isVisible = isTrc20Token

    if (isNativeToken) {
        // Native token selected
        if (!isTronNetwork) {
            gasLimitField.text = "21000"
        }
        fetchBalance()
    } else {
        // Token selected
        if (!isTronNetwork) {
            gasLimitField.text = "100000"
        }
        fetchTokenBalance()
    }
    updateTotalEstimate()
}
```

### Update `fetchTokenBalance()` for TRC20

TRC20 balance fetching now works via `blockchainService.getTokenBalance()`:

```kotlin
private fun fetchTokenBalance() {
    val tokenIndex = tokenSelector.selectedIndex - 1
    if (tokenIndex < 0 || tokenIndex >= availableTokens.size) return

    val selectedToken = availableTokens[tokenIndex]
    balanceLabel.text = "Loading..."
    balanceLabel.foreground = java.awt.Color.GRAY

    scope.launch {
        val result = blockchainService.getTokenBalance(
            contractAddress = selectedToken.contractAddress,
            walletAddress = wallet.address,
            decimals = selectedToken.decimals,
            network = network
        )

        SwingUtilities.invokeLater {
            when (result) {
                is TokenBalanceResult.Success -> {
                    currentBalanceWei = result.balanceRaw
                    val balanceFormatted = formatBalance(result.balanceFormatted)
                    balanceLabel.text = "$balanceFormatted ${selectedToken.symbol}"
                    balanceLabel.foreground = java.awt.Color.DARK_GRAY
                    balanceLoaded = true
                    checkLoadingComplete()
                }
                is TokenBalanceResult.Error -> {
                    balanceLabel.text = "Failed to load"
                    balanceLabel.foreground = java.awt.Color.RED
                }
            }
        }
    }
}
```

### Update `updateTotalEstimate()` for TRC20

Show fee limit info for TRC20 transfers:

```kotlin
private fun updateTotalEstimate() {
    try {
        val amount = amountField.text.trim().toBigDecimalOrNull() ?: BigDecimal.ZERO
        val isNativeToken = tokenSelector.selectedIndex == 0
        val isTrc20Token = isTronNetwork && !isNativeToken

        if (isTronNetwork) {
            if (isTrc20Token) {
                // TRC20: Show fee limit info
                val feeLimit = feeLimitField.text.trim().toBigDecimalOrNull() ?: BigDecimal("50")
                estimatedFeeLabel.text = "Up to $feeLimit TRX (energy)"
                estimatedFeeLabel.foreground = java.awt.Color(0xF59E0B) // Amber
            } else {
                // TRX native: Free bandwidth
                estimatedFeeLabel.text = "Free (uses bandwidth)"
                estimatedFeeLabel.foreground = java.awt.Color(0x059669) // Green
            }
            totalLabel.text = "$amount ${if (isNativeToken) network.symbol else availableTokens[tokenSelector.selectedIndex - 1].symbol}"
        } else {
            // EVM gas calculation (existing logic)
            // ...
        }
    } catch (e: Exception) {
        // ...
    }
}
```

### Add `proceedWithTrc20TokenTransaction()` Method

```kotlin
/**
 * Handle TRC20 token transfer.
 */
private fun proceedWithTrc20TokenTransaction(
    token: Token,
    toAddress: String,
    amountValue: BigDecimal
) {
    // Request password for private key
    val password = Messages.showPasswordDialog(
        "Enter wallet password to sign transaction:",
        "Sign Transaction"
    )

    if (password.isNullOrEmpty()) {
        return
    }

    // Get private key
    val privateKey: String
    try {
        privateKey = walletManager.exportPrivateKey(wallet.address, password)
    } catch (e: Exception) {
        Messages.showErrorDialog(project, "Invalid password or wallet error: ${e.message}", "Error")
        return
    }

    // Get fee limit in SUN (1 TRX = 1,000,000 SUN)
    val feeLimitTrx = feeLimitField.text.trim().toBigDecimalOrNull() ?: BigDecimal("50")
    val feeLimitSun = feeLimitTrx.multiply(BigDecimal(1_000_000L)).toLong()

    // Confirm transaction
    val confirmMessage = """
        Send $amountValue ${token.symbol} to:
        $toAddress

        Token Contract: ${token.contractAddress}
        Fee Limit: $feeLimitTrx TRX (max energy cost)

        Continue?
    """.trimIndent()

    val confirmed = Messages.showYesNoDialog(
        project,
        confirmMessage,
        "Confirm TRC20 Transfer",
        Messages.getQuestionIcon()
    )

    if (confirmed != Messages.YES) {
        return
    }

    // Disable dialog while sending
    isOKActionEnabled = false
    rootPane?.cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR)

    scope.launch {
        val result = blockchainService.sendTrc20Token(
            contractAddress = token.contractAddress,
            fromAddress = wallet.address,
            toAddress = toAddress,
            amount = amountValue,
            privateKey = privateKey,
            network = network,
            feeLimit = feeLimitSun
        )

        SwingUtilities.invokeLater {
            rootPane?.cursor = Cursor.getDefaultCursor()
            isOKActionEnabled = true

            when (result) {
                is TokenTransferResult.Success -> {
                    val message = buildString {
                        append("TRC20 transfer sent successfully!\n\n")
                        append("Transaction ID:\n${result.transactionHash}\n\n")
                        result.explorerUrl?.let {
                            append("View on TronScan:\n$it")
                        }
                    }
                    Messages.showInfoMessage(project, message, "TRC20 Transfer Sent")
                    ClipboardUtil.copyToClipboard(result.transactionHash)
                    super.doOKAction()
                }
                is TokenTransferResult.Error -> {
                    Messages.showErrorDialog(project, "TRC20 transfer failed: ${result.message}", "Error")
                }
            }
        }
    }
}
```

### Update `doOKAction()` Routing

Detect TRC20 token transfer and route appropriately:

```kotlin
// In doOKAction(), after balance checks:
if (isNativeToken) {
    if (isTronNetwork) {
        proceedWithTronTransaction(toAddress, amountValue)
    } else {
        proceedWithNativeTransaction(toAddress, amountValue, gasLimit, gasPriceWei)
    }
} else {
    if (isTronNetwork) {
        // TRC20 token transfer
        val selectedToken = availableTokens[tokenSelector.selectedIndex - 1]

        // Check token balance
        val tokenAmountRaw = amountValue.multiply(BigDecimal(BigInteger.TEN.pow(selectedToken.decimals))).toBigInteger()
        if (currentBalanceWei < tokenAmountRaw) {
            Messages.showErrorDialog(
                project,
                """
                Insufficient ${selectedToken.symbol} balance.

                Your balance: ${balanceLabel.text}
                Amount to send: $amountValue ${selectedToken.symbol}
                """.trimIndent(),
                "Insufficient Balance"
            )
            return@invokeLater
        }

        // Check TRX balance for fees (recommend at least 1 TRX)
        val trxBalance = nativeBalanceResult.balanceWei // in SUN
        val minTrxRequired = BigInteger.valueOf(1_000_000L) // 1 TRX in SUN
        if (trxBalance < minTrxRequired) {
            Messages.showWarningDialog(
                project,
                "Low TRX balance. TRC20 transfers require TRX for energy fees.\n\nCurrent TRX: ${nativeBalanceResult.balanceFormatted} TRX",
                "Low TRX Balance"
            )
        }

        proceedWithTrc20TokenTransaction(selectedToken, toAddress, amountValue)
    } else {
        // ERC20 token transfer
        proceedWithTokenTransaction(selectedToken, toAddress, amountValue, gasLimit, gasPriceWei)
    }
}
```

---

## Implementation Order

1. **BlockchainService** - Add TRC20 methods (foundation)
2. **AddTokenDialog** - Enable adding TRC20 tokens
3. **SendTokenDialog** - Enable sending TRC20 tokens
4. **Build & Test**

---

## Key Validation Rules

| Network | Address Format | Length | Validation |
|---------|---------------|--------|------------|
| EVM | Starts with `0x` | 42 chars | Hex format check |
| TRON | Starts with `T` | 34 chars | Base58Check with SHA256 checksum |

### TRON Address Validation Details

1. **Format check**: Starts with 'T', length 34
2. **Base58 decode**: Decode address to bytes
3. **Checksum verification**:
   - Address bytes = decoded[0...-4]
   - Checksum = decoded[-4...]
   - Expected = SHA256(SHA256(addressBytes))[0...4]
   - Verify checksum matches expected

---

## Testing

### Manual Testing

1. Switch to TRON Shasta network
2. Add TRC20 token: `TYzo8tjvbRRFQwYfrrbf74vDE3S3apu2nD` (EGT)
3. Verify token appears in list with balance
4. Send TRC20 tokens to another address
5. Verify transaction on Shasta TronScan

### Build Verification

```bash
./gradlew clean build
```

### Test Cases

- [x] Import TRC20 token auto-fetches metadata (symbol, name, decimals)
- [x] TRC20 token balance displays correctly in TokenListPanel
- [x] TRC20 token balance refreshes on plugin/tool window load
- [x] TRC20 token balance updates when wallet changes
- [x] TRC20 token transfer succeeds
- [x] Fee limit field only visible for TRC20 token transfers
- [x] Error handling for invalid TRON contract addresses
- [x] Base58Check validation rejects invalid addresses
