# TRON Blockchain Support Implementation Plan

**Date:** 2026-01-23
**Status:** âœ… Implemented

> **Implementation Notes:**
> - Do NOT run test cases - focus on UI implementation
> - Use built-in TRON address validation from `wallet-cli` (already in `libs/tron-wallet-1.0.jar`)

---

## Overview

Add TRON blockchain support to the MetaMask Clone IntelliJ plugin, allowing users to:
- View TRON Mainnet and Shasta Testnet in network selector
- Create, import (private key), export, and delete TRON wallets
- Display TRON wallets separately from EVM wallets based on selected network
- Show receive QR code for TRON addresses

**Not Included:** Balance queries, TRC-20 token management, send functionality.

---

## Phase 1: Data Model Changes

### 1.1 Create BlockchainType Enum
**New File:** `src/main/kotlin/dev/eastgate/metamaskclone/models/BlockchainType.kt`

```kotlin
package dev.eastgate.metamaskclone.models

import kotlinx.serialization.Serializable

@Serializable
enum class BlockchainType {
    EVM,
    TRON
}
```

**Rationale:** A simple enum provides type safety and extensibility for future blockchain types.

---

### 1.2 Update Wallet Model
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/models/Wallet.kt`

Add new field with default value for backward compatibility:

```kotlin
@Serializable
data class Wallet(
    val address: String,
    val name: String,
    val encryptedPrivateKey: String,
    val publicKey: String,
    val createdAt: String = LocalDateTime.now().toString(),
    val isImported: Boolean = false,
    val derivationPath: String? = null,
    val mnemonicId: String? = null,
    val blockchainType: BlockchainType = BlockchainType.EVM  // NEW FIELD
) {
    fun getShortAddress(): String {
        return if (address.length > 10) {
            "${address.substring(0, 6)}...${address.substring(address.length - 4)}"
        } else {
            address
        }
    }

    fun isValid(): Boolean {
        return when (blockchainType) {
            BlockchainType.EVM -> address.startsWith("0x") && address.length == 42
            BlockchainType.TRON -> address.startsWith("T") && address.length == 34
        }
    }
}
```

**Notes:**
- Default value `BlockchainType.EVM` ensures backward compatibility with existing wallets
- `isValid()` now validates based on blockchain type
- Existing serialized wallets will deserialize with the default EVM type

---

### 1.3 Update Network Model
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/core/storage/ProjectStorage.kt`

Update the Network data class:

```kotlin
@kotlinx.serialization.Serializable
data class Network(
    val id: String,
    val name: String,
    val rpcUrl: String,
    val chainId: Int,
    val symbol: String,
    val blockExplorerUrl: String? = null,
    val isTestnet: Boolean = false,
    val isCustom: Boolean = false,
    val blockchainType: BlockchainType = BlockchainType.EVM  // NEW FIELD
)
```

---

## Phase 2: TRON Wallet Generator

### 2.1 Create TronWalletGenerator
**New File:** `src/main/kotlin/dev/eastgate/metamaskclone/core/wallet/TronWalletGenerator.kt`

Uses existing `libs/tron-wallet-1.0.jar`:

```kotlin
package dev.eastgate.metamaskclone.core.wallet

import dev.eastgate.metamaskclone.models.BlockchainType
import dev.eastgate.metamaskclone.models.Wallet
import org.bouncycastle.util.encoders.Hex
import org.tron.common.crypto.ECKey
import org.tron.common.utils.Base58
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.Base64

class TronWalletGenerator {
    companion object {
        const val TRON_MAINNET_PREFIX: Byte = 0x41.toByte()
    }

    private val secureRandom = SecureRandom()

    fun generateNewWallet(name: String, password: String): Wallet {
        val ecKey = ECKey(secureRandom)
        return createWalletFromECKey(ecKey, name, password, isImported = false)
    }

    fun importWalletFromPrivateKey(
        privateKey: String,
        name: String,
        password: String
    ): Wallet {
        val cleanedKey = privateKey.removePrefix("0x").trim()

        if (!isValidPrivateKey(cleanedKey)) {
            throw IllegalArgumentException("Invalid private key format")
        }

        val privateKeyBytes = Hex.decode(cleanedKey)
        val ecKey = ECKey.fromPrivate(privateKeyBytes)
        return createWalletFromECKey(ecKey, name, password, isImported = true)
    }

    private fun createWalletFromECKey(
        ecKey: ECKey,
        name: String,
        password: String,
        isImported: Boolean
    ): Wallet {
        val addressBytes = ecKey.address
        val tronAddress = encodeToBase58Check(addressBytes)
        val privateKeyHex = Hex.toHexString(ecKey.privKeyBytes)
        val publicKeyHex = Hex.toHexString(ecKey.pubKey)
        val encryptedPrivateKey = encryptPrivateKey(privateKeyHex, password)

        return Wallet(
            address = tronAddress,
            name = name,
            encryptedPrivateKey = encryptedPrivateKey,
            publicKey = publicKeyHex,
            isImported = isImported,
            blockchainType = BlockchainType.TRON
        )
    }

    fun decryptPrivateKey(encryptedPrivateKey: String, password: String): String {
        return decryptString(encryptedPrivateKey, password)
    }

    private fun encodeToBase58Check(addressBytes: ByteArray): String {
        val hash0 = sha256(addressBytes)
        val hash1 = sha256(hash0)
        val checksum = hash1.copyOfRange(0, 4)
        val addressWithChecksum = addressBytes + checksum
        return Base58.encode(addressWithChecksum)
    }

    private fun sha256(data: ByteArray): ByteArray {
        val digest = MessageDigest.getInstance("SHA-256")
        return digest.digest(data)
    }

    private fun encryptPrivateKey(privateKey: String, password: String): String {
        return encryptString(privateKey, password)
    }

    // Reuse same encryption logic as WalletGenerator for consistency
    private fun encryptString(input: String, password: String): String {
        val keyBytes = password.toByteArray()
        val inputBytes = input.toByteArray()
        val result = ByteArray(inputBytes.size)
        for (i in inputBytes.indices) {
            result[i] = (inputBytes[i].toInt() xor keyBytes[i % keyBytes.size].toInt()).toByte()
        }
        return Base64.getEncoder().encodeToString(result)
    }

    private fun decryptString(encryptedData: String, password: String): String {
        val keyBytes = password.toByteArray()
        val encryptedBytes = Base64.getDecoder().decode(encryptedData)
        val result = ByteArray(encryptedBytes.size)
        for (i in encryptedBytes.indices) {
            result[i] = (encryptedBytes[i].toInt() xor keyBytes[i % keyBytes.size].toInt()).toByte()
        }
        return String(result)
    }

    private fun isValidPrivateKey(privateKey: String): Boolean {
        return try {
            privateKey.matches(Regex("[0-9a-fA-F]{64}"))
        } catch (_: Exception) {
            false
        }
    }

    fun generateWalletName(index: Int): String {
        return "TRON Wallet ${index + 1}"
    }
}
```

---

## Phase 3: WalletManager Updates

**File:** `src/main/kotlin/dev/eastgate/metamaskclone/core/wallet/WalletManager.kt`

### Key Changes:

1. Add TronWalletGenerator instance
2. Add methods that accept BlockchainType parameter
3. Add filtering methods for wallets by blockchain type

```kotlin
class WalletManager(private val project: Project) {
    private val walletGenerator = WalletGenerator()
    private val tronWalletGenerator = TronWalletGenerator()  // NEW
    private val storage = ProjectStorage.getInstance(project)

    // ... existing fields ...

    // NEW: Get wallets filtered by blockchain type
    fun getWalletsForBlockchainType(blockchainType: BlockchainType): List<Wallet> {
        return _wallets.value.filter { it.blockchainType == blockchainType }
    }

    // NEW: Count wallets by blockchain type (for naming)
    fun getWalletCountForType(blockchainType: BlockchainType): Int {
        return _wallets.value.count { it.blockchainType == blockchainType }
    }

    // UPDATED: Create wallet with blockchain type
    fun createWallet(
        name: String? = null,
        password: String,
        blockchainType: BlockchainType = BlockchainType.EVM
    ): Wallet {
        val walletCount = getWalletCountForType(blockchainType)
        val walletName = name ?: when (blockchainType) {
            BlockchainType.EVM -> walletGenerator.generateWalletName(walletCount)
            BlockchainType.TRON -> tronWalletGenerator.generateWalletName(walletCount)
        }

        val wallet = when (blockchainType) {
            BlockchainType.EVM -> walletGenerator.generateNewWallet(walletName, password)
            BlockchainType.TRON -> tronWalletGenerator.generateNewWallet(walletName, password)
        }

        val updatedWallets = _wallets.value + wallet
        _wallets.value = updatedWallets
        storage.saveWallets(updatedWallets)

        if (_selectedWallet.value == null ||
            _selectedWallet.value?.blockchainType == blockchainType) {
            _selectedWallet.value = wallet
        }

        return wallet
    }

    // UPDATED: Import wallet with blockchain type
    fun importWallet(
        privateKey: String,
        name: String? = null,
        password: String,
        blockchainType: BlockchainType = BlockchainType.EVM
    ): Wallet {
        val walletName = name ?: when (blockchainType) {
            BlockchainType.EVM -> "Imported Wallet"
            BlockchainType.TRON -> "Imported TRON Wallet"
        }

        val wallet = when (blockchainType) {
            BlockchainType.EVM -> walletGenerator.importWalletFromPrivateKey(privateKey, walletName, password)
            BlockchainType.TRON -> tronWalletGenerator.importWalletFromPrivateKey(privateKey, walletName, password)
        }

        // Check if wallet already exists (same address AND same blockchain type)
        if (_wallets.value.any {
            it.address.equals(wallet.address, ignoreCase = true) &&
            it.blockchainType == blockchainType
        }) {
            throw IllegalArgumentException("Wallet with this address already exists")
        }

        val updatedWallets = _wallets.value + wallet
        _wallets.value = updatedWallets
        storage.saveWallets(updatedWallets)

        if (_selectedWallet.value == null ||
            _selectedWallet.value?.blockchainType == blockchainType) {
            _selectedWallet.value = wallet
        }

        return wallet
    }

    // UPDATED: Export private key (blockchain-aware decryption)
    fun exportPrivateKey(address: String, password: String): String {
        val wallet = _wallets.value.find {
            it.address.equals(address, ignoreCase = true)
        } ?: throw IllegalArgumentException("Wallet not found")

        return when (wallet.blockchainType) {
            BlockchainType.EVM -> walletGenerator.decryptPrivateKey(wallet.encryptedPrivateKey, password)
            BlockchainType.TRON -> tronWalletGenerator.decryptPrivateKey(wallet.encryptedPrivateKey, password)
        }
    }

    // NEW: Select first wallet for given blockchain type
    fun selectFirstWalletForType(blockchainType: BlockchainType) {
        val walletsOfType = getWalletsForBlockchainType(blockchainType)
        _selectedWallet.value = walletsOfType.firstOrNull()
    }
}
```

---

## Phase 4: Network Configuration

### 4.1 Add TRON Networks
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/core/network/PredefinedNetworks.kt`

```kotlin
object PredefinedNetworks {
    // ... existing EVM networks ...

    // TRON Networks (chainId = -1 since TRON doesn't use EVM chainId)
    val TRON_MAINNET = Network(
        id = "TRON_MAINNET",
        name = "TRON Mainnet",
        rpcUrl = "https://api.trongrid.io",
        chainId = -1,
        symbol = "TRX",
        blockExplorerUrl = "https://tronscan.org",
        isTestnet = false,
        isCustom = false,
        blockchainType = BlockchainType.TRON
    )

    val TRON_SHASTA = Network(
        id = "TRON_SHASTA",
        name = "TRON Shasta Testnet",
        rpcUrl = "https://api.shasta.trongrid.io",
        chainId = -1,
        symbol = "TRX",
        blockExplorerUrl = "https://shasta.tronscan.org",
        isTestnet = true,
        isCustom = false,
        blockchainType = BlockchainType.TRON
    )

    val ALL_NETWORKS = listOf(
        BNB_TESTNET,
        BNB_MAINNET,
        ETHEREUM_SEPOLIA,
        ETHEREUM_MAINNET,
        POLYGON_TESTNET,
        POLYGON_MAINNET,
        TRON_SHASTA,      // NEW
        TRON_MAINNET      // NEW
    )

    val DEFAULT_ENABLED_IDS = listOf(
        "BNB_TESTNET",
        "ETH_SEPOLIA",
        "POLYGON_TESTNET",
        "TRON_SHASTA"  // NEW - enable TRON testnet by default
    )

    // NEW: Get networks by blockchain type
    fun getNetworksByBlockchainType(blockchainType: BlockchainType): List<Network> {
        return ALL_NETWORKS.filter { it.blockchainType == blockchainType }
    }
}
```

### 4.2 Update NetworkManager
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/core/network/NetworkManager.kt`

Add method to get current blockchain type:

```kotlin
// NEW: Get blockchain type of currently selected network
fun getCurrentBlockchainType(): BlockchainType {
    return _selectedNetwork.value.blockchainType
}
```

---

## Phase 5: UI Updates

### 5.1 MetaMaskToolWindow
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/MetaMaskToolWindow.kt`

**Key changes:**
1. Filter wallets based on current network's blockchain type
2. Auto-select appropriate wallet when network changes
3. Update wallet popup menu to pass blockchain type

```kotlin
private fun observeChanges() {
    // Observe network changes - UPDATE THIS
    scope.launch {
        networkManager.selectedNetwork.collect { network ->
            SwingUtilities.invokeLater {
                networkSelectorBar.updateNetwork(network)
                // Select appropriate wallet for this blockchain type
                selectWalletForCurrentBlockchainType()
                updateBalanceDisplay()
                updateTokensUI()
            }
            refreshTokenBalances()
        }
    }
    // ... rest unchanged ...
}

// NEW: Helper method to select wallet matching current blockchain type
private fun selectWalletForCurrentBlockchainType() {
    val blockchainType = networkManager.getCurrentBlockchainType()
    val currentWallet = walletManager.selectedWallet.value

    // If current wallet doesn't match blockchain type, switch
    if (currentWallet == null || currentWallet.blockchainType != blockchainType) {
        walletManager.selectFirstWalletForType(blockchainType)
    }
}

// UPDATE: showWalletSelectionPopup to filter by blockchain type
private fun showWalletSelectionPopup() {
    val blockchainType = networkManager.getCurrentBlockchainType()
    val wallets = walletManager.getWalletsForBlockchainType(blockchainType)

    // ... show filtered wallets in popup ...
    // Update menu labels based on blockchain type
}
```

---

### 5.2 CreateWalletDialog
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/CreateWalletDialog.kt`

Add blockchain type parameter:

```kotlin
class CreateWalletDialog(
    private val project: Project,
    private val walletManager: WalletManager,
    private val blockchainType: BlockchainType = BlockchainType.EVM  // NEW
) : DialogWrapper(project) {

    init {
        title = when (blockchainType) {
            BlockchainType.EVM -> "Create New Wallet"
            BlockchainType.TRON -> "Create New TRON Wallet"
        }
        init()
    }

    override fun createCenterPanel(): JComponent {
        // Update default name based on blockchain type
        val walletCount = walletManager.getWalletCountForType(blockchainType)
        nameField.text = when (blockchainType) {
            BlockchainType.EVM -> "Wallet ${walletCount + 1}"
            BlockchainType.TRON -> "TRON Wallet ${walletCount + 1}"
        }
        // ... rest of UI ...
    }

    override fun doOKAction() {
        // Pass blockchain type to walletManager.createWallet()
        val wallet = walletManager.createWallet(name, password, blockchainType)
        // ...
    }
}
```

---

### 5.3 ImportWalletDialog
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/ImportWalletDialog.kt`

Similar changes to CreateWalletDialog:

```kotlin
class ImportWalletDialog(
    private val project: Project,
    private val walletManager: WalletManager,
    private val blockchainType: BlockchainType = BlockchainType.EVM  // NEW
) : DialogWrapper(project) {

    init {
        title = when (blockchainType) {
            BlockchainType.EVM -> "Import Wallet"
            BlockchainType.TRON -> "Import TRON Wallet"
        }
        init()
    }

    // ... update labels and pass blockchainType to importWallet() ...
}
```

---

### 5.4 ReceiveDialog
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/ReceiveDialog.kt`

Update labels based on wallet type:

```kotlin
override fun createCenterPanel(): JComponent {
    // Update title based on wallet type
    val titleText = when (wallet.blockchainType) {
        BlockchainType.EVM -> "Your Address"
        BlockchainType.TRON -> "Your TRON Address"
    }

    // Update warning based on blockchain type
    val warningText = when (wallet.blockchainType) {
        BlockchainType.EVM -> "Only send tokens on the same EVM network."
        BlockchainType.TRON -> "Only send TRX and TRC tokens to this address."
    }
    // ... QR code works automatically (uses wallet.address) ...
}
```

---

### 5.5 NetworkSelectionDialog
**File:** `src/main/kotlin/dev/eastgate/metamaskclone/ui/dialogs/NetworkSelectionDialog.kt`

Update network initial display for TRON:

```kotlin
private fun getNetworkInitial(network: Network): String {
    return when {
        network.symbol.equals("ETH", ignoreCase = true) -> "E"
        network.symbol.equals("BNB", ignoreCase = true) ||
            network.symbol.equals("tBNB", ignoreCase = true) -> "B"
        network.symbol.equals("MATIC", ignoreCase = true) -> "P"
        network.symbol.equals("TRX", ignoreCase = true) -> "T"  // NEW
        else -> network.symbol.firstOrNull()?.uppercase() ?: "?"
    }
}
```

---

## Phase 6: Use Built-in TRON Address Validation

**Use existing utilities from `libs/tron-wallet-1.0.jar`** (from wallet-cli):

| Method | Description |
|--------|-------------|
| `WalletApi.addressValid(String addressBase58)` | Validates Base58 TRON address |
| `WalletApi.decode58Check(String input)` | Decodes and validates checksum |
| `DecodeUtil.addressValid(byte[] address)` | Validates address bytes (0x41 prefix, 21 bytes) |

**Key validation logic** (already implemented in wallet-cli):

```java
// From WalletApi.java - decode58Check
public static byte[] decode58Check(String input) {
    byte[] decodeCheck = Base58.decode(input);
    if (decodeCheck.length <= 4) return null;

    byte[] decodeData = new byte[decodeCheck.length - 4];
    System.arraycopy(decodeCheck, 0, decodeData, 0, decodeData.length);

    byte[] hash0 = Sha256Sm3Hash.hash(decodeData);
    byte[] hash1 = Sha256Sm3Hash.hash(hash0);

    // Verify checksum (last 4 bytes)
    if (hash1[0] == decodeCheck[decodeData.length] &&
        hash1[1] == decodeCheck[decodeData.length + 1] &&
        hash1[2] == decodeCheck[decodeData.length + 2] &&
        hash1[3] == decodeCheck[decodeData.length + 3]) {
        return decodeData;
    }
    return null;
}
```

**No custom validation code needed** - use the built-in methods directly.

---

## Files Summary

| File | Action |
|------|--------|
| `models/BlockchainType.kt` | CREATE |
| `models/Wallet.kt` | MODIFY - add blockchainType field |
| `core/storage/ProjectStorage.kt` | MODIFY - add blockchainType to Network |
| `core/wallet/TronWalletGenerator.kt` | CREATE |
| `core/wallet/WalletManager.kt` | MODIFY - add blockchain-aware methods |
| `core/network/PredefinedNetworks.kt` | MODIFY - add TRON networks |
| `core/network/NetworkManager.kt` | MODIFY - add getCurrentBlockchainType() |
| `ui/MetaMaskToolWindow.kt` | MODIFY - filter wallets by blockchain type |
| `ui/dialogs/CreateWalletDialog.kt` | MODIFY - add blockchainType parameter |
| `ui/dialogs/ImportWalletDialog.kt` | MODIFY - add blockchainType parameter |
| `ui/dialogs/ReceiveDialog.kt` | MODIFY - update labels for TRON |
| `ui/dialogs/NetworkSelectionDialog.kt` | MODIFY - add TRX network initial |

---

## Verification Steps

1. **Build:** `./gradlew clean build`
2. **Manual Testing** (no test cases - focus on UI):
   - Switch to TRON Shasta network
   - Create TRON wallet (verify T-prefix, 34 chars)
   - Import private key as TRON wallet
   - Export private key (verify same as input)
   - Delete TRON wallet
   - Switch to EVM network (verify TRON wallets hidden)
   - Switch back to TRON (verify TRON wallets shown)
   - Open Receive dialog (verify QR code works)

---

## Key Technical Notes

- Same private key produces different addresses on EVM vs TRON (different encoding)
- TRON uses: secp256k1 + Keccak-256 + 0x41 prefix + Base58Check
- EVM uses: secp256k1 + Keccak-256 + 0x prefix + hex encoding
- `libs/tron-wallet-1.0.jar` provides: `ECKey`, `Base58`, `Hash`
- Backward compatibility: existing wallets default to `BlockchainType.EVM`
